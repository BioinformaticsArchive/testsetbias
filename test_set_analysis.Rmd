# Analysis run for Cross-platform TSP

#First, we load all the libraries, files, and data.

```{r dependencies, eval=TRUE}
set.seed(47209)
library(tspreg)
library(rpart)
library(rattle)
library(genefu) # has the genes for PAM50
library(colorspace) # colors for plots
library(ggplot2)
library(plyr)
library(affyPLM)
library(survival)
library(pamr)
library(survcomp)
library(MetaGx)
source("fit_rpart.R")
source("newreg.R")
source("subset_fit.R")
source("build_chimera.R")
source("model_tree.R")
source("predict_prob_table.R")
source("make_prob_table.R")
#source("download_esets.R")
load("/amber2/scratch/persmed/BC/1_15_2014_eset.Rda")
load("data/pair_sim_out.Rda")
load("data/100_pair_out.Rda")
```

We begin by building a five-feature predictive model for breast
cancer subtype using an affy hgu133plus2 and an agilent dataset separately.
We also test the  model on all of the available datasets. We used GSE5460 
for affy because it had the most complete records of any hgu133plus2 dataset. Here, we also subset the 
expression data to only the genes in the PAM50 set.

```{r init, cache=TRUE, warning=FALSE}

n <- sum(unlist(lapply(lapply(eset.all, dim), "[[", 2)))
# 6297

table(unlist(lapply(eset.all, function(x){pData(x)$node})))
n - sum(table(unlist(lapply(eset.all, function(x){pData(x)$node}))))
#   0    1    2
#2857 1871    2
# 1567 NA

table(unlist(lapply(eset.all, function(x){pData(x)$er})))
n - sum(table(unlist(lapply(eset.all, function(x){pData(x)$er}))))
#    0    1
# 1556 3635
# 1106 NA

table(unlist(lapply(eset.all, function(x){pData(x)$grade})))
n - sum(table(unlist(lapply(eset.all, function(x){pData(x)$grade}))))
#   1    2    3
# 525 1642 2226
# 1904 NA

table(unlist(lapply(eset.all, function(x){pData(x)$her2})))
n - sum(table(unlist(lapply(eset.all, function(x){pData(x)$her2}))))
#   0    1
# 1437  496
# 4364 NA

table(unlist(lapply(eset.all, function(x){pData(x)$subtype})))

# Basal   Her2   LumB   LumA Normal
#  1254    927   2007   1813    296

summary(unlist(lapply(eset.all, function(x){pData(x)$t.rfs})))

#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's
#      3    1164    2280    2637    3915    9218    2991

sd(unlist(lapply(eset.all, function(x){pData(x)$t.rfs})), na.rm=T)
# 1772.906

table(unlist(lapply(eset.all, function(x){pData(x)$pgr})))

#  0   1
# 656 766
# 4875 NA

summary(unlist(lapply(eset.all, function(x){pData(x)$age})))

#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's
#  21.00   47.00   56.40   57.29   67.24   96.29    1547

sd(unlist(lapply(eset.all, function(x){pData(x)$age})), na.rm=T)

# 13.42863

summary(unlist(lapply(eset.all, function(x){pData(x)$size})))

#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's
# -9.000   1.600   2.200   2.521   3.000  18.200    1720

sd(unlist(lapply(eset.all, function(x){pData(x)$size})), na.rm=T)

#1.434876

# Here, we are simplifying the platform labels so that we can look at like technologies together

platforms <- unlist(lapply(eset.all, annotation))
platforms[c(1,11,25)] <- "agilent"
platforms[c(21,28)] <- "illumina"
platforms[c(12,16)] <- "swegene"
platforms[c(3,4,5,17,22)] <- "other"

# Find the union and intersection of probes across all experiments

length(Reduce(union, lapply(eset.all, rownames)))
length(Reduce(intersect, lapply(eset.all, rownames)))

dat_affy <- eset.all$GSE5460
mat_affy <- exprs(dat_affy)
PAM50_names <- rownames(pam50$centroids.map)
genes_affy <- unlist(sapply(PAM50_names, function(x){rownames(fData(dat_affy))[which(fData(dat_affy)$SYMBOL == x)]}))
mat_affy <- mat_affy[genes_affy,]

idx_affy <- sample(1:ncol(mat_affy),round(ncol(mat_affy)/3))
train_affy <- mat_affy[,-idx_affy]
test_affy <- mat_affy[,idx_affy]
train_outcome_affy <- pData(dat_affy)$subtype[-idx_affy]
test_outcome_affy <- pData(dat_affy)$subtype[idx_affy]

dat_ag <- eset.all$ISDB10845
mat_ag <- exprs(dat_ag)
genes_ag <- unlist(sapply(PAM50_names, function(x){rownames(fData(dat_ag))[which(fData(dat_ag)$SYMBOL == x)]}))
mat_ag <- mat_ag[genes_ag,]

idx_ag <- sample(1:ncol(mat_ag),round(ncol(mat_ag)/3))
train_ag <- mat_ag[,-idx_ag]
test_ag <- mat_ag[,idx_ag]
train_outcome_ag <- pData(dat_ag)$subtype[-idx_ag]
test_outcome_ag <- pData(dat_ag)$subtype[idx_ag]

dat_il <- eset.all$ISDB10278
mat_il <- exprs(dat_il)
genes_il <- unlist(sapply(PAM50_names, function(x){rownames(fData(dat_il))[which(fData(dat_il)$SYMBOL == x)]}))
mat_il <- mat_il[genes_il,]

idx_il <- sample(1:ncol(mat_il),round(ncol(mat_il)/3))
train_il <- mat_il[,-idx_il]
test_il <- mat_il[,idx_il]
train_outcome_il <- pData(dat_il)$subtype[-idx_il]
test_outcome_il <- pData(dat_il)$subtype[idx_il]
```

We have written a modification of the rpart procedure for creating a
classification tree, which we call using rpart_cond. This function will
produce the top five pairs that best predict the outcome conditional
on the other pairs in the model.

```{r rpart_cond, cache=TRUE, fig.width=15, fig.height=12, warning=FALSE}

tsp_affy <- rpart_cond(train_affy, as.factor(train_outcome_affy), 5)
pairmat_affy <- calculateTspairs(train_affy, tsp_affy)
tree_affy <- create_model_tree(pairmat_affy$pairMat, train_outcome_affy, tsp_affy)

test_preds_affy <- predict_model_tree(test_affy, genes_affy, tree_affy, tsp_affy)

all_preds_affy <- lapply(eset.all, function(x){
	out <- predict_model_tree(exprs(x), genes_affy, tree_affy, tsp_affy)
	
	annot <- fData(x)
	names(annot)[1] <- "EntrezGene.ID"
	annot$probe <- rownames(annot)

	subtype_noscale <- intrinsic.cluster.predict(sbt.model=pam50, data=t(exprs(x)), annot=annot,do.mapping=T)$subtype

	list("accuracy" = sum(out$pred==pData(x)$subtype,na.rm=T)/sum(!is.na(pData(x)$subtype)),
	     "accuracy_noscale" = sum(out$pred==subtype_noscale,na.rm=T)/sum(!is.na(subtype_noscale)),
	     "pairs" = out$pair,
	     "platform" = annotation(x))
})

tsp_ag <- rpart_cond(train_ag, as.factor(train_outcome_ag), 5)
pairmat_ag <- calculateTspairs(train_ag, tsp_ag)
tree_ag <- create_model_tree(pairmat_ag$pairMat, train_outcome_ag, tsp_ag)

test_preds_ag <- predict_model_tree(test_ag, genes_ag, tree_ag, tsp_ag)

all_preds_ag <- lapply(eset.all, function(x){
	out <- predict_model_tree(exprs(x), genes_ag, tree_ag, tsp_ag)

 	annot <- fData(x)
        names(annot)[1] <- "EntrezGene.ID"
        annot$probe <- rownames(annot)

        subtype_noscale <- intrinsic.cluster.predict(sbt.model=pam50, data=t(exprs(x)), annot=annot,do.mapping=T)$subtype

	list("accuracy" = sum(out$pred==pData(x)$subtype,na.rm=T)/sum(!is.na(pData(x)$subtype)),
	     "accuracy_noscale" = sum(out$pred==subtype_noscale,na.rm=T)/sum(!is.na(subtype_noscale)),
	     "pairs" = out$pair,
	     "platform" = annotation(x))
})

tsp_il <- rpart_cond(train_il, as.factor(train_outcome_il), 5)
pairmat_il <- calculateTspairs(train_il, tsp_il)
tree_il <- create_model_tree(pairmat_il$pairMat, train_outcome_il, tsp_il)

test_preds_il <- predict_model_tree(test_il, genes_il, tree_il, tsp_il)

all_preds_il <- lapply(eset.all, function(x){
        out <- predict_model_tree(exprs(x), genes_il, tree_il, tsp_il)
	annot <- fData(x)
        names(annot)[1] <- "EntrezGene.ID"
        annot$probe <- rownames(annot)

        subtype_noscale <- intrinsic.cluster.predict(sbt.model=pam50, data=t(exprs(x)), annot=annot,do.mapping=T)$subtype

        list("accuracy" = sum(out$pred==pData(x)$subtype,na.rm=T)/sum(!is.na(pData(x)$subtype)),
	     "accuracy_noscale" = sum(out$pred==subtype_noscale,na.rm=T)/sum(!is.na(subtype_noscale)),
	     "accuracy_pam50" = sum(subtype_noscale==pData(x)$subtype,na.rm=T)/sum(!is.na(pData(x)$subtype)),
             "pairs" = out$pair,
             "platform" = annotation(x))
})

ac_affy <- unlist(lapply(all_preds_affy, "[[", "accuracy"))
ac_ag <- unlist(lapply(all_preds_ag, "[[", "accuracy"))
ac_il <- unlist(lapply(all_preds_il, "[[", "accuracy"))

ac_affy_noscale <- unlist(lapply(all_preds_affy, "[[", "accuracy_noscale"))
ac_ag_noscale <- unlist(lapply(all_preds_ag, "[[", "accuracy_noscale"))
ac_il_noscale <- unlist(lapply(all_preds_il, "[[", "accuracy_noscale"))

ac_pam <- unlist(lapply(all_preds_il, "[[", "accuracy_pam50"))

nm <- c("133a", "133plus2", "95", "agilent", "illumina", "other", "swegene")
par(mfrow=c(1,3))
boxplot(ac_affy~platforms, main = "Accuracy for affy hgu133plus2", col=rainbow_hcl(7), names=nm)
points(as.numeric(as.factor(platforms)), ac_affy)
boxplot(ac_ag~platforms, main="Accuracy for Agilent G4110A/B/Custom", col=rainbow_hcl(7), names=nm)
points(as.numeric(as.factor(platforms)), ac_ag)
boxplot(ac_il~platforms, main="Accuracy for Illumina HT12-V3.0", col=rainbow_hcl(7), names=nm)
points(as.numeric(as.factor(platforms)), ac_il)

par(mfrow=c(1,3))
boxplot(ac_affy_noscale~platforms, main = "Accuracy for affy hgu133plus2 (noScale)", col=rainbow_hcl(7), names=nm)
points(as.numeric(as.factor(platforms)), ac_affy_noscale)
boxplot(ac_ag_noscale~platforms, main="Accuracy for Agilent G4110A/B/Custom (noScale)", col=rainbow_hcl(7), names=nm)
points(as.numeric(as.factor(platforms)), ac_ag_noscale)
boxplot(ac_il_noscale~platforms, main="Accuracy for Illumina HT12-V3.0 (noScale)", col=rainbow_hcl(7), names=nm)
points(as.numeric(as.factor(platforms)), ac_il_noscale)

boxplot(ac_pam~platforms, main="Accuracy (PAM50 scaled and noScale)", col=rainbow_hcl(7), names=nm)
points(as.numeric(as.factor(platforms)), ac_pam)

# Look at ER status as a surrogate for comparing TSP and SSP (PAM)

affy_test <- eset.all$GSE7390

annot <- fData(affy_test)
names(annot)[1] <- "EntrezGene.ID"
annot$probe <- rownames(annot)

affy_test_preds <- predict_model_tree(exprs(affy_test), genes_affy, tree_affy, tsp_affy)
affy_test_noscale <- intrinsic.cluster.predict(sbt.model=pam50, data=t(exprs(affy_test)), annot=annot,do.mapping=T)$subtype

tab_pred <- table(affy_test_preds$pred, pData(affy_test)$er)
tab_pam <- table(pData(affy_test)$subtype, pData(affy_test)$er)
tab_pam_noscale <- table(affy_test_noscale, pData(affy_test)$er)

lab <- c("LumA", "LumB")

sd_lab_tsp <- setdiff(rownames(tab_pred), lab)
sd_lab_pam <- setdiff(rownames(tab_pam), lab)
sd_lab_pam_noscale <- setdiff(rownames(tab_pam_noscale), lab)

tsp_er_p <- sum(tab_pred[lab,2])/sum(tab_pred[lab,1:2])
tsp_er_n <- sum(tab_pred[sd_lab_tsp,1])/sum(tab_pred[sd_lab_tsp,1:2])

pam_er_p <- sum(tab_pam[lab,2])/sum(tab_pam[lab,1:2])
pam_er_n <- sum(tab_pam[sd_lab_pam,1])/sum(tab_pam[sd_lab_pam,1:2])

pam_er_p_noscale <- sum(tab_pam_noscale[lab,2])/sum(tab_pam_noscale[lab,1:2])
pam_er_n_noscale <- sum(tab_pam_noscale[sd_lab_pam_noscale,1])/sum(tab_pam_noscale[sd_lab_pam_noscale,1:2])

cat("Affy\n")
cbind("TSP ER+"=tsp_er_p, "TSP ER-"=tsp_er_n, "PAM ER+"=pam_er_p, "PAM ER-"=pam_er_n, "PAM ER+ (NoScale)"=pam_er_p_noscale, "PAM ER- (NoScale)"=pam_er_n_noscale)

ag_test <- eset.all$ISDB10228

annot <- fData(ag_test)
names(annot)[1] <- "EntrezGene.ID"
annot$probe <- rownames(annot)

ag_test_preds <- predict_model_tree(exprs(ag_test), genes_ag, tree_ag, tsp_ag)
ag_test_noscale <- intrinsic.cluster.predict(sbt.model=pam50, data=t(exprs(ag_test)), annot=annot,do.mapping=T)$subtype

tab_pred <- table(ag_test_preds$pred, pData(ag_test)$er)
tab_pam <- table(pData(ag_test)$subtype, pData(ag_test)$er)
tab_pam_noscale <- table(ag_test_noscale, pData(ag_test)$er)

lab <- c("LumA", "LumB")

sd_lab_tsp <- setdiff(rownames(tab_pred), lab)
sd_lab_pam <- setdiff(rownames(tab_pam), lab)
sd_lab_pam_noscale <- setdiff(rownames(tab_pam_noscale), lab)

tsp_er_p <- sum(tab_pred[lab,2])/sum(tab_pred[lab,1:2])
tsp_er_n <- sum(tab_pred[sd_lab_tsp,1])/sum(tab_pred[sd_lab_tsp,1:2])

pam_er_p <- sum(tab_pam[lab,2])/sum(tab_pam[lab,1:2])
pam_er_n <- sum(tab_pam[sd_lab_pam,1])/sum(tab_pam[sd_lab_pam,1:2])

pam_er_p_noscale <- sum(tab_pam_noscale[lab,2])/sum(tab_pam_noscale[lab,1:2])
pam_er_n_noscale <- sum(tab_pam_noscale[sd_lab_pam_noscale,1])/sum(tab_pam_noscale[sd_lab_pam_noscale,1:2])

cat("Agilent\n")
cbind("TSP ER+"=tsp_er_p, "TSP ER-"=tsp_er_n, "PAM ER+"=pam_er_p, "PAM ER-"=pam_er_n, "PAM ER+ (NoScale)"=pam_er_p_noscale, "PAM ER- (NoScale)"=pam_er_n_noscale)

il_test <- eset.all$ISDB10842

annot <- fData(il_test)
names(annot)[1] <- "EntrezGene.ID"
annot$probe <- rownames(annot)

il_test_preds <- predict_model_tree(exprs(il_test), genes_il, tree_il, tsp_il)
il_test_noscale <- intrinsic.cluster.predict(sbt.model=pam50, data=t(exprs(il_test)), annot=annot,do.mapping=T)$subtype

tab_pred <- table(il_test_preds$pred, pData(il_test)$er)
tab_pam <- table(pData(il_test)$subtype, pData(il_test)$er)
tab_pam_noscale <- table(il_test_noscale, pData(il_test)$er)

lab <- c("LumA", "LumB")

sd_lab_tsp <- setdiff(rownames(tab_pred), lab)
sd_lab_pam <- setdiff(rownames(tab_pam), lab)
sd_lab_pam_noscale <- setdiff(rownames(tab_pam_noscale), lab)

tsp_er_p <- sum(tab_pred[lab,2])/sum(tab_pred[lab,1:2])
tsp_er_n <- sum(tab_pred[sd_lab_tsp,1])/sum(tab_pred[sd_lab_tsp,1:2])

pam_er_p <- sum(tab_pam[lab,2])/sum(tab_pam[lab,1:2])
pam_er_n <- sum(tab_pam[sd_lab_pam,1])/sum(tab_pam[sd_lab_pam,1:2])

pam_er_p_noscale <- sum(tab_pam_noscale[lab,2])/sum(tab_pam_noscale[lab,1:2])
pam_er_n_noscale <- sum(tab_pam_noscale[sd_lab_pam_noscale,1])/sum(tab_pam_noscale[sd_lab_pam_noscale,1:2])

cat("Illumina\n")
cbind("TSP ER+"=tsp_er_p, "TSP ER-"=tsp_er_n, "PAM ER+"=pam_er_p, "PAM ER-"=pam_er_n, "PAM ER+ (NoScale)"=pam_er_p_noscale, "PAM ER- (NoScale)"=pam_er_n_noscale)
```

The above boxplots show that a model trained on one platform has variable predictive accuracy across different
platforms. Notably, both models perform extremely poorly on affy hgu95.

To explore the robustness of our modeling approach, we now examine the efficacy of a "chimeric" training set. We
will take 100 records (or as many as are available) from 10 datasets covering various platforms within the three
major microarray technologies (agilent, illumina, affymetrix). These records will be combined into one dataset
with corresponding gene information for the intersection of genes that appear in each dataset. We will
use this dataset to train a new predictor and compare its accuracy to the accuracy we saw with the single-platform
predictors.

```{r chimera, cache=TRUE, fig.width=15, fig.height=12, warning=FALSE}
dat_chim <- build_chimera(eset.all[c(1,2,5,6,9,11,14,15,18,19,23,26,28)],"subtype",num=100) 

mat_chim <- dat_chim$dat
genes_chim <- unlist(sapply(PAM50_names, function(x){rownames(fData(eset.all[[26]]))[which(fData(eset.all[[26]])$SYMBOL == x)]}))
genes_chim <- genes_chim[genes_chim %in% rownames(mat_chim)]
mat_chim <- mat_chim[genes_chim,]

idx_chim <- sample(1:ncol(mat_chim),round(ncol(mat_chim)/3))
train_chim <- mat_chim[,-idx_chim]
test_chim <- mat_chim[,idx_chim]
train_outcome_chim <- dat_chim$out[-idx_chim]
test_outcome_chim <- dat_chim$out[idx_chim]

tsp_chim <- rpart_cond(train_chim, as.factor(train_outcome_chim), 5)
pairmat_chim <- calculateTspairs(train_chim, tsp_chim)
tree_chim <- create_model_tree(pairmat_chim$pairMat, train_outcome_chim, tsp_chim)

test_preds_chim <- predict_model_tree(test_chim, genes_chim, tree_chim, tsp_chim)

all_preds_chim <- lapply(eset.all, function(x){
        out <- predict_model_tree(exprs(x), genes_chim, tree_chim, tsp_chim)
        list("accuracy" = sum(out$pred==pData(x)$subtype,na.rm=T)/sum(!is.na(pData(x)$subtype)),
             "pairs" = out$pair,
             "platform" = annotation(x))
})


ac_chim <- unlist(lapply(all_preds_chim, "[[", "accuracy"))
colors <- rainbow_hcl(length(unique(platforms)))

par(mfrow = c(1, 3))
plot(ac_chim - ac_affy, col = colors[as.factor(platforms)], pch = 19, ylab = "Chimera accuracy - affy accuracy", 
    xlab="Platform (Index)", main = "Change in Accuracy (Affy)", cex = 1.2, ylim=c(-0.4,0.7))
abline(h = 0, lty = "dashed")
plot(ac_chim - ac_ag, col = colors[as.factor(platforms)], pch = 19, ylab = "Chimera accuracy - agilent accuracy", 
        xlab="Platform (Index)", main = "Change in Accuracy (Agilent)", cex = 1.2, ylim=c(-0.4,0.7))
abline(h = 0, lty = "dashed")
legend("bottomleft", legend = unique(platforms), fill = colors[as.factor(unique(platforms))], 
    bty = "n")
plot(ac_chim - ac_il, col = colors[as.factor(platforms)], pch = 19, ylab = "Chimera accuracy - illumina accuracy", 
        xlab="Platform (Index)", main = "Change in Accuracy (Illumina)", cex = 1.2, ylim=c(-0.4,0.7))
abline(h = 0, lty = "dashed")

par(mfrow=c(1,1))
boxplot(ac_chim~platforms, main = "Accuracy for chimera", col=rainbow_hcl(7), names=nm)
points(as.numeric(as.factor(platforms)), ac_chim)


```

We now compare our TSP predictor built on the chimeric data with the existing PAM50 predictor in
a variety of settings. We will use reported ER status, which is obtained via IHC and therefore independent
of genetic data. Any true LumA/B patient will also be ER+, so we will examine how concordant the TSP
and PAM50 predictions are with ER status. We will investigate the effects of applying different
normalization methods, as well as in biased populations (progressively adding patients to a dataset;
all patients are ER+).

```{r comparison, cache=TRUE, fig.width=15, fig.height=12, warning=FALSE}
# First, let's see how the TSP and PAM predictions compare to ER status (LumA/B == ER+)

affy <- eset.all$GSE7390 # This dataset was not included in the chimera

affy_pred <- predict_model_tree(exprs(affy), genes_chim, tree_chim, tsp_chim)$pred
annot <- fData(affy)
names(annot)[1] <- "EntrezGene.ID"
annot$probe <- rownames(annot)
# pam50.robust applies centering/scaling to the data
affy_pam <- intrinsic.cluster.predict(sbt.model=pam50.robust, data=t(exprs(affy)), annot=annot,do.mapping=T)$subtype
# pam50 does not center/scale the data
affy_pam_noscale <- intrinsic.cluster.predict(sbt.model=pam50, data=t(exprs(affy)), annot=annot,do.mapping=T)$subtype

table(affy_pam, affy_pam_noscale)

tab_pred <- table(affy_pred, pData(affy)$er)
tab_pam <- table(affy_pam, pData(affy)$er)

lab <- c("LumA", "LumB")
sd_lab_tsp <- setdiff(rownames(tab_pred), lab)
sd_lab_pam <- setdiff(rownames(tab_pam), lab)

tsp_er_p <- sum(tab_pred[lab,2])/sum(tab_pred[lab,1:2])
tsp_er_n <- sum(tab_pred[sd_lab_tsp,1])/sum(tab_pred[sd_lab_tsp,1:2])

pam_er_p <- sum(tab_pam[lab,2])/sum(tab_pam[lab,1:2])
pam_er_n <- sum(tab_pam[sd_lab_pam,1])/sum(tab_pam[sd_lab_pam,1:2])

cbind("TSP ER+"=tsp_er_p, "TSP ER-"=tsp_er_n, "PAM ER+"=pam_er_p, "PAM ER-"=pam_er_n)

# Next, let's see if predictions change significantly as we reduce the dataset to two patients,
# then progressively add more.

num <- c(2, 10, 20, 40, 80, 100, 120)
prog_outcome <- matrix(NA, 3, length(num))

for(i in 1:length(num)){
	tmp_pred <- predict_model_tree(exprs(affy)[,1:num[i]], genes_chim, tree_chim, tsp_chim)$pred
	tmp_pam <- intrinsic.cluster.predict(sbt.model=pam50.robust, data=t(exprs(affy))[1:num[i],], annot=annot,do.mapping=T)$subtype
	tmp_pam_noscale <- intrinsic.cluster.predict(sbt.model=pam50, data=t(exprs(affy))[1:num[i],], annot=annot,do.mapping=T)$subtype

	prog_outcome[1,i] <- sum(tmp_pred == affy_pred[1:num[i]])/length(tmp_pred)
	prog_outcome[2,i] <- sum(tmp_pam == affy_pam[1:num[i]])/length(tmp_pam)
 	prog_outcome[3,i] <- sum(tmp_pam_noscale == affy_pam[1:num[i]])/length(tmp_pam_noscale)
}

prog_outcome

# Next, let us remove all of the ER+ people from this dataset and see how the predictions compare to the original ones.

er_idx <- which(pData(affy)$er == 0)

affy_pred_er <- predict_model_tree(exprs(affy)[,er_idx], genes_chim, tree_chim, tsp_chim)$pred
affy_pam_er <- intrinsic.cluster.predict(sbt.model=pam50.robust, data=t(exprs(affy)[,er_idx]), annot=annot,do.mapping=T)$subtype
affy_pam_er_noscale <- intrinsic.cluster.predict(sbt.model=pam50, data=t(exprs(affy)[,er_idx]), annot=annot,do.mapping=T)$subtype

cbind("TSP ER- ONLY"=sum(affy_pred_er == affy_pred[er_idx])/length(affy_pred_er), "PAM ER- ONLY"=sum(affy_pam_er == affy_pam[er_idx])/length(affy_pam_er))

# Next we will normalize the expression values by three different methods: quantile, scaling, and invariantset

affy_q <- normalize.ExpressionSet.quantiles(affy)
affy_s <- normalize.ExpressionSet.scaling(affy)
affy_i <- normalize.ExpressionSet.invariantset(affy)

affy_q_er <- normalize.ExpressionSet.quantiles(affy[,er_idx])
affy_s_er <- normalize.ExpressionSet.scaling(affy[,er_idx])
affy_i_er <- normalize.ExpressionSet.invariantset(affy[,er_idx])


q_pred <- predict_model_tree(exprs(affy_q), genes_chim, tree_chim, tsp_chim)$pred
q_pam <- intrinsic.cluster.predict(sbt.model=pam50.robust, data=t(exprs(affy_q)), annot=annot,do.mapping=T)$subtype
q_pam_noscale <- intrinsic.cluster.predict(sbt.model=pam50, data=t(exprs(affy_q)), annot=annot,do.mapping=T)$subtype

q_pred_er <- predict_model_tree(exprs(affy_q_er), genes_chim, tree_chim, tsp_chim)$pred
q_pam_er <- intrinsic.cluster.predict(sbt.model=pam50.robust, data=t(exprs(affy_q_er)), annot=annot,do.mapping=T)$subtype
q_pam_er_noscale <- intrinsic.cluster.predict(sbt.model=pam50, data=t(exprs(affy_q_er)), annot=annot,do.mapping=T)$subtype

s_pred <- predict_model_tree(exprs(affy_s), genes_chim, tree_chim, tsp_chim)$pred
s_pam <- intrinsic.cluster.predict(sbt.model=pam50.robust, data=t(exprs(affy_s)), annot=annot,do.mapping=T)$subtype
s_pam_noscale <- intrinsic.cluster.predict(sbt.model=pam50, data=t(exprs(affy_s)), annot=annot,do.mapping=T)$subtype

s_pred_er <- predict_model_tree(exprs(affy_s_er), genes_chim, tree_chim, tsp_chim)$pred
s_pam_er <- intrinsic.cluster.predict(sbt.model=pam50.robust, data=t(exprs(affy_s_er)), annot=annot,do.mapping=T)$subtype
s_pam_er_noscale <- intrinsic.cluster.predict(sbt.model=pam50, data=t(exprs(affy_s_er)), annot=annot,do.mapping=T)$subtype

i_pred <- predict_model_tree(exprs(affy_i), genes_chim, tree_chim, tsp_chim)$pred
i_pam <- intrinsic.cluster.predict(sbt.model=pam50.robust, data=t(exprs(affy_i)), annot=annot,do.mapping=T)$subtype
i_pam_noscale <- intrinsic.cluster.predict(sbt.model=pam50, data=t(exprs(affy_i)), annot=annot,do.mapping=T)$subtype

i_pred_er <- predict_model_tree(exprs(affy_i_er), genes_chim, tree_chim, tsp_chim)$pred
i_pam_er <- intrinsic.cluster.predict(sbt.model=pam50.robust, data=t(exprs(affy_i_er)), annot=annot,do.mapping=T)$subtype
i_pam_er_noscale <- intrinsic.cluster.predict(sbt.model=pam50, data=t(exprs(affy_i_er)), annot=annot,do.mapping=T)$subtype


norm_outcome <- matrix(c(sum(q_pred==affy_pred)/length(q_pred), sum(q_pam==affy_pam)/length(q_pam), sum(q_pam_noscale==affy_pam_noscale)/length(q_pam_noscale),
			 sum(s_pred==affy_pred)/length(s_pred), sum(s_pam==affy_pam)/length(s_pam), sum(s_pam_noscale==affy_pam_noscale)/length(s_pam_noscale),
			sum(i_pred==affy_pred)/length(i_pred), sum(i_pam==affy_pam)/length(i_pam),sum(i_pam_noscale==affy_pam_noscale)/length(i_pam_noscale),
			sum(q_pred_er==affy_pred[er_idx])/length(q_pred_er), sum(q_pam_er==affy_pam[er_idx])/length(q_pam_er),sum(q_pam_er_noscale==affy_pam_noscale[er_idx])/length(q_pam_er_noscale),
                         sum(s_pred_er==affy_pred[er_idx])/length(s_pred_er), sum(s_pam_er==affy_pam[er_idx])/length(s_pam_er),sum(s_pam_er_noscale==affy_pam_noscale[er_idx])/length(s_pam_er_noscale),
                        sum(i_pred_er==affy_pred[er_idx])/length(i_pred_er), sum(i_pam_er==affy_pam[er_idx])/length(i_pam_er),sum(i_pam_er_noscale==affy_pam_noscale[er_idx])/length(i_pam_er_noscale)), 6,3)

rownames(norm_outcome) <- c("TSP", "PAM", "PAM NoScale", "TSP ER- ONLY", "PAM ER- ONLY", "PAM ER- ONLY NoScale")
colnames(norm_outcome) <- c("Quantile", "Scaling", "Invariantset")

norm_outcome

affy <- eset.all$GSE7390 # This dataset was not included in the chimera
annot <- fData(affy)
names(annot)[1] <- "EntrezGene.ID"
annot$probe <- rownames(annot)
# pam50.robust applies centering/scaling to the data
affy_pam <- intrinsic.cluster.predict(sbt.model=pam50.robust, data=t(exprs(affy)), annot=annot,do.mapping=T)$subtype

num <- c(2, 10, 20, 40, 80, 100, 120)
prog <- matrix(NA, 100, length(num))
n <- 100

for(i in 1:length(num)){
	for(j in 1:n){
		idx <- sample(colnames(exprs(affy)), num[i], replace=F)
	        tmp_pam <- intrinsic.cluster.predict(sbt.model=pam50.robust, data=t(exprs(affy))[idx,], annot=annot,do.mapping=T)$subtype
		prog[j,i] <- sum(tmp_pam == affy_pam[idx])/length(tmp_pam)
	}
}

boxplot(prog, names=num, outline=F,xlab="# Samples", ylab="% Concordance with Full Predictions", main="Changes in predictions on scaled data as more patients are added")
for(i in 1:length(num)){
	points(jitter(rep(i, n), amount=1/(i+3)), prog[,i], pch=21, bg="dodgerblue1", col="black")
}

# Split data into er- and er+ groups
er_min_sub <- exprs(affy)[,pData(affy)$samplename[which(pData(affy)$er == 0)]]
er_max_sub <- exprs(affy)[,pData(affy)$samplename[which(pData(affy)$er == 1)]]

er_min_out <- affy_pam[which(pData(affy)$er == 0)]
er_max_out <- affy_pam[which(pData(affy)$er == 1)]
names(er_min_out) <- colnames(er_min_sub)
names(er_max_out) <- colnames(er_max_sub)

n2 <- 100
prog_mean <- prog_sd <- vector("numeric", 41)

# Let's go from all ER- to all ER+

for(i in 0:40){
	cur <- vector("numeric", n2)
	for(j in 1:n2){
		idx_min <- sample(colnames(er_min_sub), i, replace=F)
		idx_max <- sample(colnames(er_max_sub), 40-i, replace=F)
		dat <- cbind(er_min_sub[,idx_min], er_max_sub[,idx_max])
		st <- c(er_min_out[idx_min], er_max_out[idx_max])
		tmp_pam <- intrinsic.cluster.predict(sbt.model=pam50.robust, data=t(dat), annot=annot,do.mapping=T)$subtype		
		cur[j] <- sum(tmp_pam == st)/length(tmp_pam)
	}		
	
	prog_mean[i+1] <- mean(cur)
	prog_sd[i+1] <- sd(cur)
}

plot(prog_mean, type="l", ylim=c(0.7, 1), col="dodgerblue1",lwd=2, xlab="% ER negative in Population", ylab="% Concordance with Full Predictions", xaxt="n", main="Predictions vary as ER composition of patient set varies")
axis(1, at=seq(0,40,10), labels=round(seq(0,40,10)/40, 2))
lines(prog_mean - prog_sd, lty="dashed", col="red")
lines(prog_mean + prog_sd, lty="dashed", col="red")

```

Next, we will examine the effect of missing pairs on predictions. We will remove sets of pairs and examine how much
the predictions change.

```{r remove_probe, cache=TRUE, fig.width=15, fig.height=12, warning=FALSE}
mat <- exprs(affy)
mat <- make_mat(mat, genes_chim) # This gives us a sub-matrix of only the genes in the chimera dataset so the indices match up
chim_idx <- as.numeric(unique(unlist(sapply(tsp_chim, strsplit, "<")))) # Now we have the unique indices to remove
chim_table <- expand.grid( rep( list( c(FALSE, TRUE)), length(chim_idx))) 
chim_table <- chim_table[-c(1,nrow(chim_table)),]

miss_pred_ac <- vector("numeric", nrow(chim_table))
pairs_used <- matrix(NA, nrow(chim_table), length(tsp_chim))
for(i in 1:nrow(chim_table)){
        tmp_mat <- mat[-chim_idx[unlist(chim_table[i,])],] # tmp_mat has all rows except the current
	tmp_preds <- predict_model_tree(tmp_mat, genes_chim, tree_chim, tsp_chim)
	miss_pred_ac[i] <- sum(tmp_preds$pred==affy_pred)/length(tmp_preds)
	pairs_used[i,] <- as.numeric(tmp_preds$pairs)
}

pairs_tmp <- pairs_used[-which(rowSums(pairs_used) == 1 | rowSums(pairs_used) == 0),] # Remove models with 0/1 pairs
ac_tmp <- miss_pred_ac[-which(rowSums(pairs_used) == 1 | rowSums(pairs_used) == 0)]

# Check the accuracy of each subset (when Pair x is available)
tmp <- sapply(1:5, function(x){
	idx <- which(pairs_tmp[,x] == 1)
	ac_tmp[idx]	
})

boxplot(tmp, col=colors, main = "Model Consistency by Pair Availibility", xlab="Pair", ylab="% Agreement with Original Predictions")

```

We are also interested in the possibility of probe-effect mitigation via TSP modeling. We will examine which genes are most
commonly selected for a 5-pair classifier using three different platforms, then compare that to the genes most commonly
selected for a 5-plair classifier trained on the "chimera" of the three.

```{r probe, cache=TRUE, eval=TRUE, warning=FALSE}

data_list <- eset.all[c(13,25,28)]
# This is a chimera of just the three example affy, agilent, and illumina datasets
dat_chim2 <- build_chimera(data_list,"subtype",num=125)

mat_chim2 <- dat_chim2$dat
genes_chim2 <- unlist(sapply(PAM50_names, function(x){rownames(fData(eset.all[[26]]))[which(fData(eset.all[[26]])$SYMBOL == x)]}))
genes_chim2 <- genes_chim2[genes_chim2 %in% rownames(mat_chim2)]
mat_chim2 <- mat_chim2[genes_chim2,]

idx_chim2 <- sample(1:ncol(mat_chim2),round(ncol(mat_chim2)/3))
train_chim2 <- mat_chim2[,-idx_chim2]
train_outcome_chim2 <- dat_chim2$out[-idx_chim2]

tsp_chim2 <- rpart_cond(train_chim2, as.factor(train_outcome_chim2), 5)
pairmat_chim2 <- calculateTspairs(train_chim2, tsp_chim2)
tree_chim2 <- create_model_tree(pairmat_chim2$pairMat, train_outcome_chim2, tsp_chim2)

# Let's see how our models predict on each of the three datasets in the chimera
# in comparison with the chimera itself

output <- do.call(rbind, lapply(data_list, function(dat){
	affy_pred <- predict_model_tree(exprs(dat), genes_affy, tree_affy, tsp_affy)
	ag_pred <- predict_model_tree(exprs(dat), genes_ag, tree_ag, tsp_ag)
	il_pred <- predict_model_tree(exprs(dat), genes_il, tree_il, tsp_il)
	chim2_pred <- predict_model_tree(exprs(dat), genes_chim2, tree_chim2, tsp_chim2)
	
	cbind(sum(affy_pred$pred == pData(dat)$subtype)/length(pData(dat)$subtype),
	      sum(ag_pred$pred == pData(dat)$subtype)/length(pData(dat)$subtype),
	      sum(il_pred$pred == pData(dat)$subtype)/length(pData(dat)$subtype),
	      sum(chim2_pred$pred == pData(dat)$subtype)/length(pData(dat)$subtype))
}))

rownames(output) <- c("Affy", "Agilent", "Illumina")
colnames(output) <- c("Affy", "Agilent", "Illumina", "Chimera")

output

# Next, we will build a chimeric model from just Affy and Agilent and see if
# the Illumina predictions are better than either one.

dat_chim3 <- build_chimera(data_list[1:2],"subtype",num=125)

mat_chim3 <- dat_chim3$dat
genes_chim3 <- unlist(sapply(PAM50_names, function(x){rownames(fData(eset.all[[26]]))[which(fData(eset.all[[26]])$SYMBOL == x)]}))
genes_chim3 <- genes_chim3[genes_chim3 %in% rownames(mat_chim3)]
mat_chim3 <- mat_chim3[genes_chim3,]

idx_chim3 <- sample(1:ncol(mat_chim3),round(ncol(mat_chim3)/3))
train_chim3 <- mat_chim3[,-idx_chim3]
train_outcome_chim3 <- dat_chim3$out[-idx_chim3]

tsp_chim3 <- rpart_cond(train_chim3, as.factor(train_outcome_chim3), 5)
pairmat_chim3 <- calculateTspairs(train_chim3, tsp_chim3)
tree_chim3 <- create_model_tree(pairmat_chim3$pairMat, train_outcome_chim3, tsp_chim3)

chim3_pred <- predict_model_tree(exprs(data_list[[3]]), genes_chim3, tree_chim3, tsp_chim3)

sum(chim3_pred$pred == pData(data_list[[3]])$subtype)/length(pData(data_list[[3]])$subtype)
 
```
Although the concordance of the predictions using the comibined Affy/Agilent data is still around 60%,
it shows a marked improvement from the 40-50% that each platform performed alone.


This is separated out because it requires a good deal of time to run.
```{r probe_sim, cache=TRUE, eval=FALSE, warning=FALSE}

tspair2gene <- function(tsp_idx, genelist){
        tmp_idx <- sapply(tsp_idx,strsplit,"<")
        unlist(lapply(tmp_idx,function(x){paste(genelist[as.numeric(x)],collapse="<")}))
}

affy_pair_sim <- ag_pair_sim <- il_pair_sim <- chim_pair_sim <- c()

nsim=100

for(i in 1:nsim){
	# Sample to create training and test sets each time
	idx_affy <- sample(1:ncol(mat_affy),round(ncol(mat_affy)/3))
	train_affy <- mat_affy[,-idx_affy]
	train_outcome_affy <- pData(dat_affy)$subtype[-idx_affy]

	idx_ag <- sample(1:ncol(mat_ag),round(ncol(mat_ag)/3))
	train_ag <- mat_ag[,-idx_ag]
	train_outcome_ag <- pData(dat_ag)$subtype[-idx_ag]
	
	idx_il <- sample(1:ncol(mat_il),round(ncol(mat_il)/3))
	train_il <- mat_il[,-idx_il]
	train_outcome_il <- pData(dat_il)$subtype[-idx_il]

	idx_chim2 <- sample(1:ncol(mat_chim2),round(ncol(mat_chim2)/3))
	train_chim2 <- mat_chim2[,-idx_chim2]
	train_outcome_chim2 <- dat_chim2$out[-idx_chim2]
	
	affy_tsp_tmp <- rpart_cond(train_affy, as.factor(train_outcome_affy), 5)
	ag_tsp_tmp <- rpart_cond(train_ag, as.factor(train_outcome_ag), 5)
	il_tsp_tmp <- rpart_cond(train_il, as.factor(train_outcome_il), 5)
	chim_tsp_tmp <- rpart_cond(train_chim2, as.factor(train_outcome_chim2), 5)

	# Using unique just to see which genes are chosen, not how many times (e.g. one gene could be in multilpe pairs
	affy_pair_sim <- c(affy_pair_sim, unique(unlist(sapply(tspair2gene(affy_tsp_tmp, genes_affy), strsplit, "<"))))
	ag_pair_sim <- c(ag_pair_sim, unique(unlist(sapply(tspair2gene(ag_tsp_tmp, genes_ag), strsplit, "<"))))
	il_pair_sim <- c(il_pair_sim, unique(unlist(sapply(tspair2gene(il_tsp_tmp, genes_il), strsplit, "<"))))
	chim_pair_sim <- c(chim_pair_sim, unique(unlist(sapply(tspair2gene(chim_tsp_tmp, genes_chim2), strsplit, "<"))))

}

pair_out <- t(rbind.fill.matrix(rbind(table(affy_pair_sim)), rbind(table(ag_pair_sim)),rbind(table(il_pair_sim)), rbind(table(chim_pair_sim))))

rownames(pair_out) <- fData(eset.all[[28]])[rownames(pair_out),"SYMBOL"]
colnames(pair_out) <- c("affy", "agilent", "illumina", "chimera")


```

I have saved the results of running the above code in "100_pair_out.Rda", and I will use them below...
If the above code is run, comment out the load() command.

```{r proc_pair, cache=TRUE, fig.width=15, fig.height=12, eval=TRUE, warning=FALSE}
nsim=100

pair_out[which(is.na(pair_out))] <- 0

pair_out <- pair_out[order(pair_out[,4],decreasing=T),]

image(nsim-pair_out, axes=F,col=sequential_hcl(12,h=250,c=10))
axis(2, c(0,0.33,0.66,1),c("affy", "agilent", "illumina", "chimera"))
axis(1, seq(0,1,length.out=47), rownames(pair_out),tick=F,las=3,cex.axis=0.75)

```

Next, we will examine the pairs in particular that are chosen and whether or not the outcome classification
differs across platforms

```{r chim_pair_sim, cache=TRUE, fig.width=15, fig.height=12, eval=FALSE, warning=FALSE}

nsim=25
affy_pairs <- ag_pairs <- il_pairs <- chim_pairs <- vector("list", nsim)
for(i in 1:nsim){
        # Sample to create training and test sets each time
        idx_affy <- sample(1:ncol(mat_affy),round(ncol(mat_affy)/3))
        train_affy <- mat_affy[,-idx_affy]
        train_outcome_affy <- pData(dat_affy)$subtype[-idx_affy]

        idx_ag <- sample(1:ncol(mat_ag),round(ncol(mat_ag)/3))
        train_ag <- mat_ag[,-idx_ag]
        train_outcome_ag <- pData(dat_ag)$subtype[-idx_ag]

        idx_il <- sample(1:ncol(mat_il),round(ncol(mat_il)/3))
        train_il <- mat_il[,-idx_il]
        train_outcome_il <- pData(dat_il)$subtype[-idx_il]

        idx_chim2 <- sample(1:ncol(mat_chim2),round(ncol(mat_chim2)/3))
        train_chim2 <- mat_chim2[,-idx_chim2]
        train_outcome_chim2 <- dat_chim2$out[-idx_chim2]

        affy_tsp_tmp <- rpart_cond(train_affy, as.factor(train_outcome_affy), 5)
        ag_tsp_tmp <- rpart_cond(train_ag, as.factor(train_outcome_ag), 5)
        il_tsp_tmp <- rpart_cond(train_il, as.factor(train_outcome_il), 5)
        chim_tsp_tmp <- rpart_cond(train_chim2, as.factor(train_outcome_chim2), 5)

        affy_pairs[[i]] <- affy_tsp_tmp
        ag_pairs[[i]] <- ag_tsp_tmp
        il_pairs[[i]] <- il_tsp_tmp
        chim_pairs[[i]] <- chim_tsp_tmp

}


```
The list outcomes above are saved in "pair_sim_out.Rda", so load that file below.

```{r chim_pair, cache=TRUE, fig.width=15, fig.height=12, eval=TRUE, warning=FALSE}
nsim=25


pair_plot <- function(pair, txt){
	ids <- tspair2gene(pair, genes_chim2)
	symbols <- geneid2symbol(eset.all[[28]], ids)
	ids <- lapply(ids, strsplit, "<")

	colors <- rainbow_hcl(5)
	color_lev <- colors[as.factor(dat_chim2$outcome)]
	par(mfrow=c(2,3))
	for(i in 1:length(ids)){
		plot(dat_chim2$dat[ids[[i]][[1]][1],] - dat_chim2$dat[ids[[i]][[1]][[2]],], main=symbols[i], col=color_lev, ylab="Difference in expression",xaxt="n", pch=19)
		axis(1,at=c(62.5, 187.5, 312.5),tick=FALSE,labels=c("Affy", "Agilent", "Illumina"))
		abline(h=0, lty="dashed")
		abline(v=125, lty="dashed", col="gray")
		abline(v=250, lty="dashed", col="gray")
	}
	plot(1, type="n", axes=F, xlab="", ylab="", main=txt)
	legend("center", fill=colors, legend=unique(as.factor(dat_chim2$outcome)))
}

affy_ids <- names(unlist(lapply(apply(do.call(rbind, affy_pairs),2, table), which.max)))
pair_plot(affy_ids, "Affy Pairs")

ag_ids <- names(unlist(lapply(apply(do.call(rbind, ag_pairs),2, table), which.max)))
ag_ids # NOTE: the last pair chosen for ag was different in each simulation, so it defaults to showing pair #4
# I am manually showing a different pair as pair 5 for the sake of variety
ag_ids[5] <- "10<38"
pair_plot(ag_ids, "Agilent Pairs")

il_ids <- names(unlist(lapply(apply(do.call(rbind, il_pairs),2, table), which.max)))
pair_plot(il_ids, "Illumina Pairs")

chim_ids <- names(unlist(lapply(apply(do.call(rbind, chim_pairs),2, table), which.max)))
pair_plot(chim_ids, "Chimera Pairs")

```

```{r build_final, cache=TRUE, fig.width=15, fig.height=12, eval=TRUE, warning=FALSE}
dat_chim <- build_chimera(eset.all[c(1,2,6,7,11,15,21,28)],"subtype",num=200)

mat_chim <- dat_chim$dat
genes_chim <- unlist(sapply(PAM50_names, function(x){rownames(fData(eset.all[[28]]))[which(fData(eset.all[[28]])$SYMBOL == x)]}))
genes_chim <- genes_chim[genes_chim %in% rownames(mat_chim)]
mat_chim <- mat_chim[genes_chim,]

idx_chim <- sample(1:ncol(mat_chim),round(ncol(mat_chim)/3))
train_chim <- mat_chim[,-idx_chim]
test_chim <- mat_chim[,idx_chim]
train_outcome_chim <- dat_chim$out[-idx_chim]
test_outcome_chim <- dat_chim$out[idx_chim]

tsp_chim <- rpart_cond(train_chim, as.factor(train_outcome_chim), 5)
pairmat_chim <- calculateTspairs(train_chim, tsp_chim)
tree_chim <- create_model_tree(pairmat_chim$pairMat, train_outcome_chim, tsp_chim)

test_preds_chim <- predict_model_tree(test_chim, genes_chim, tree_chim, tsp_chim)

all_preds_chim <- lapply(eset.all, function(x){

	annot <- fData(x)
        names(annot)[1] <- "EntrezGene.ID"
        annot$probe <- rownames(annot)

        out <- predict_model_tree(exprs(x), genes_chim, tree_chim, tsp_chim)
        list("preds" = out$pred,
	     "accuracy" = sum(out$pred==pData(x)$subtype,na.rm=T)/sum(!is.na(pData(x)$subtype)),
             "pairs" = out$pair,
             "platform" = annotation(x),
	     "preds_noscale" = intrinsic.cluster.predict(sbt.model=pam50, data=t(exprs(x)), annot=annot,do.mapping=T)$subtype
)
})

# ISDB10843 does not have enough pairs to produce predictions, so we will ignore it

ac_chim <- unlist(lapply(all_preds_chim, "[[", "accuracy"))

boxplot(ac_chim ~ platforms, main = "TSP Model Accuracy", ylab="% Concordance with PAM50 predictions", col = rainbow_hcl(7), 
    names = nm)
points(as.numeric(as.factor(platforms)), ac_chim, pch=21, col="black", bg="dodgerblue1")


# Summary of accuracy on all platforms and excluding other/swegene

summary(ac_chim)
IQR(ac_chim)
summary(ac_chim[-which(platforms=="other"|platforms=="swegene")])
IQR(ac_chim[-which(platforms=="other"|platforms=="swegene")])

# Final Tree
colnames(pairmat_chim$pairMat) <- geneid2symbol(eset.all[[28]],tspair2gene(tsp_chim, genes_chim))
tree_chim_named <- create_model_tree(pairmat_chim$pairMat, train_outcome_chim, tsp_chim)
drawTreeNodes(tree_chim_named[[rep("1",5)]])

# Final TSPs
geneid2symbol(eset.all[[28]],tspair2gene(tsp_chim, genes_chim))

# Look at differentiation in survival, comparing our predictions to PAM50

all <- do.call(rbind, lapply(eset.all[c(1:4, 6:27)], pData)) # We are excluding metabric due to dominiant sample size
all$tsp_pred <- factor(unlist(lapply(all_preds_chim[c(1:4, 6:27)], "[[", "preds")))
all$preds_noscale <- factor(unlist(lapply(all_preds_chim[c(1:4, 6:27)], "[[", "preds_noscale")))


# Final counts of each subtype for:

# PAM50
table(all$subtype)

# PAM50 no scale
table(all$preds_noscale)

# TSP
table(all$tsp_pred)

# K-M estimators for all subtypers

s1 <- survfit(Surv(t.dfs, e.dfs)~subtype, data=all)
s2 <- survfit(Surv(t.dfs, e.dfs)~tsp_pred, data=all)
s3 <- survfit(Surv(t.dfs, e.dfs)~preds_noscale, data=all)

cat_names <- c("Basal", "Her2", "LumA", "LumB", "Normal")

par(mfrow=c(1,3))
plot(s1, col=colors[c(1,2,4,3,5)], main="PAM50 Subtype Survival", xlab="Time (days)", ylab="Survival Probability") # Order is different when normal is predicted
legend("bottomleft", legend=cat_names, fill = colors[1:5], bty="n", cex=1.5)

plot(s3, col=colors[1:5], main="PAM Subtype Survival (noScale)", xlab="Time (days)", ylab="Survival Probability")
legend("bottomleft", legend=cat_names[1:5], fill = colors[1:5], bty="n", cex=1.5)

plot(s2, col=colors[1:5], main="TSP Subtype Survival", xlab="Time (days)", ylab="Survival Probability")
legend("bottomleft", legend=cat_names[1:5], fill = colors[1:5], bty="n", cex=1.5)

# Cox Prop. Hazard models for both subtypers, using Luminal A as baseline
cp1 <- coxph(Surv(t.dfs, e.dfs)~relevel(subtype,ref="LumA"), data=all)
cp2 <- coxph(Surv(t.dfs, e.dfs)~relevel(tsp_pred,ref="LumA"), data=all)
cp3 <- coxph(Surv(t.dfs, e.dfs)~relevel(preds_noscale,ref="LumA"), data=all)


cp1_low <- exp(cp1$coef - 1.96*sqrt(diag(cp1$var)))
cp1_up <- exp(cp1$coef + 1.96*sqrt(diag(cp1$var)))

cp1_out <- cbind(exp(cp1$coef), cp1_low, cp1_up)
rownames(cp1_out) <- c("Basal", "Her2", "LumB", "Normal")
colnames(cp1_out) <- c("HR Estimate", "95%L", "95%U")

cp2_low <- exp(cp2$coef - 1.96*sqrt(diag(cp2$var)))
cp2_up <- exp(cp2$coef + 1.96*sqrt(diag(cp2$var)))

cp2_out <- cbind(exp(cp2$coef), cp2_low, cp2_up)
rownames(cp2_out) <- c("Basal", "Her2", "LumB", "Normal")
colnames(cp2_out) <- c("HR Estimate", "95%L", "95%U")

cp3_low <- exp(cp3$coef - 1.96*sqrt(diag(cp3$var)))
cp3_up <- exp(cp3$coef + 1.96*sqrt(diag(cp3$var)))

cp3_out <- cbind(exp(cp3$coef), cp3_low, cp3_up)
rownames(cp3_out) <- c("Basal", "Her2", "LumB","Normal")
colnames(cp3_out) <- c("HR Estimate", "95%L", "95%U")

cp1_out
cp3_out
cp2_out

# Forest plot of hazard ratios

x <- rep(c("Basal", "Her2", "LumB", "Normal"), 3)
y <- c(2.081, 2.279, 1.956, 1.750, 1.907, 1.843, 2.150, 1.329,
       1.974, 2.000, 1.785, 1.650)
ylo <- c(1.703, 1.820, 1.628, 1.161, 1.558, 1.451, 1.814, 1.026,
         1.608, 1.563, 1.496, 1.051)
yhi <- c(2.542, 2.853, 2.350, 2.638, 2.335, 2.340, 2.549, 1.723,
         2.423, 2.559, 2.130, 2.590)
n <- c(932, 649, 1179, 217, 648, 371, 822, 299, 782, 508, 1527, 101)

d <- data.frame(x=x, y=y, ylo=ylo, yhi=yhi, category=rep(c("PAM50", "PAM50 (unscaled)", "TSP"), each=4), n=n, class_col=rep(colors[c(1,2,4,5)],3))

ggplot(d, aes(x=category, y=y, ymin=ylo, ymax=yhi,color=factor(x))) + scale_color_manual(values=colors,guide='none')  + geom_linerange(lwd=1) + coord_flip() + geom_point(aes(size=n)) + geom_hline(aes(yintercept=1), lty=2) + xlab('Classifier') + ylab('Hazard Ratio (95% CI)') + facet_grid(~x) + theme(axis.text=element_text(size=12), axis.title=element_text(size=14,face="bold"), strip.text.x=element_text(size=14))

```
NOTE: This is currently non-functional.
Now that our final model has been trained, we examine its stability in qRT-PCR data.

```{r rtpcr, cache=TRUE, fig.width=15, fig.height=12, eval=FALSE, warning=FALSE}

gid <- geneid2symbol(eset.all[[28]], genes_chim) # Need to change to symbols because that's what we have in RT-PCR

tmp <- eset_rtpcr[[1]] # The Parker data
preds <- predict_model_tree(exprs(tmp), gid, tree_chim, tsp_chim)
annot <- fData(tmp)
names(annot)[1] <- "probe"
names(annot)[2] <- "EntrezGene.ID"
annot$probe <- rownames(annot)
preds_noscale <- intrinsic.cluster.predict(sbt.model=pam50, data=t(exprs(tmp)), annot=annot,do.mapping=T)$subtype

tab_pred <- table(preds$pred, pData(tmp)$er)
tab_pam <- table(pData(tmp)$subtype, pData(tmp)$er)
tab_pam_noscale <- table(preds_noscale, pData(tmp)$er)


# Parker TSP ER+
sum(tab_pred[2:3,2])/sum(tab_pred[2:3,1:2])
# Parker TSP ER-
sum(tab_pred[1,1])/sum(tab_pred[1,1:2])

# Parker PAM50 ER+ (scaled)
sum(tab_pam[3:4,2])/sum(tab_pam[3:4,1:2])
# Parker PAM50 ER- (scaled)
sum(tab_pam[1:2,1])/sum(tab_pam[1:2,1:2])

# Parker PAM50 ER+
sum(tab_pam_noscale[3:4,2])/sum(tab_pam_noscale[3:4,1:2])
# Parker PAM50 ER-
sum(tab_pam_noscale[1:2,1])/sum(tab_pam_noscale[1:2,1:2])


# Only this RT-PCR data has survival outcomes, so let us see how our predictors compare

s1 <- survfit(Surv(as.numeric(pData(tmp)[,"t rfs"]), as.numeric(pData(tmp)[,"e rfs"]))~pData(tmp)$subtype)
s2 <- survfit(Surv(as.numeric(pData(tmp)[,"t rfs"]), as.numeric(pData(tmp)[,"e rfs"]))~preds$pred)
s3 <- survfit(Surv(as.numeric(pData(tmp)[,"t rfs"]), as.numeric(pData(tmp)[,"e rfs"]))~preds_noscale)


cat_names <- c("Basal", "Her2", "LumA", "LumB", "Normal")

par(mfrow=c(1,3))
plot(s1, col=colors[c(1,2,4,3,5)], main="PAM50 Subtype Survival", sub = "RT-PCR") # Order is different when normal is predicted
legend("bottomleft", legend=cat_names, fill = colors[c(1,2,4,3,5)])

plot(s3, col=colors[c(1,2,4,3,5)], main="PAM50 Subtype Survival (noscale)", sub = "RT-PCR") # Order is different when normal is predicted
legend("bottomleft", legend=cat_names, fill = colors[c(1,2,4,3,5)])

plot(s2, col=colors[c(1,2,4)], main="TSP Subtype Survival", sub="RT-PCR")
legend("bottomleft", legend=cat_names[c(1,2,4)], fill = colors[c(1,2,4)])

# Cox Prop. Hazard models for both subtypers, using Luminal A as baseline
cp1 <- coxph(Surv(as.numeric(pData(tmp)[,"t rfs"]), as.numeric(pData(tmp)[,"e rfs"]))~relevel(pData(tmp)$subtype, "LumA"))
cp2 <- coxph(Surv(as.numeric(pData(tmp)[,"t rfs"]), as.numeric(pData(tmp)[,"e rfs"]))~relevel(factor(preds$pred), "LumA"))
cp3 <- coxph(Surv(as.numeric(pData(tmp)[,"t rfs"]), as.numeric(pData(tmp)[,"e rfs"]))~relevel(factor(preds_noscale), "LumA"))

cp1_low <- exp(cp1$coef - 1.96*sqrt(diag(cp1$var)))
cp1_up <- exp(cp1$coef + 1.96*sqrt(diag(cp1$var)))

cp1_out <- cbind(exp(cp1$coef), cp1_low, cp1_up)
rownames(cp1_out) <- c("Basal", "Her2", "LumB", "Normal")
colnames(cp1_out) <- c("HR Estimate", "95%L", "95%U")

cp2_low <- exp(cp2$coef - 1.96*sqrt(diag(cp2$var)))
cp2_up <- exp(cp2$coef + 1.96*sqrt(diag(cp2$var)))

cp2_out <- cbind(exp(cp2$coef), cp2_low, cp2_up)
#rownames(cp2_out) <- c("Basal", "Her2", "LumB")
rownames(cp2_out) <- c("Basal", "LumB")
colnames(cp2_out) <- c("HR Estimate", "95%L", "95%U")

cp3_low <- exp(cp3$coef - 1.96*sqrt(diag(cp3$var)))
cp3_up <- exp(cp3$coef + 1.96*sqrt(diag(cp3$var)))

cp3_out <- cbind(exp(cp3$coef), cp3_low, cp3_up)
rownames(cp3_out) <- c("Basal", "Her2", "LumB", "Normal")
colnames(cp3_out) <- c("HR Estimate", "95%L", "95%U")

#PAM50 scaled
cp1_out
#PAM50 noscale
cp3_out
#TSP
cp2_out

tmp <- eset_rtpcr[[2]] # The Nielsen data
preds <- predict_model_tree(exprs(tmp), gid, tree_chim, tsp_chim)
annot <- fData(tmp)
names(annot)[1] <- "probe"
names(annot)[2] <- "EntrezGene.ID"
preds_noscale <- intrinsic.cluster.predict(sbt.model=pam50, data=t(exprs(tmp)), annot=annot,do.mapping=T)$subtype

tab_pred <- table(preds$pred, pData(tmp)$er)
tab_pam <- table(pData(tmp)$subtype, pData(tmp)$er)
tab_pam_noscale <- table(preds$pred, pData(tmp)$er)

# Nielsen TSP ER+
sum(tab_pred[3:4,1])/sum(tab_pred)

# Nielsen PAM ER+
sum(tab_pam[3:4,1])/sum(tab_pam)

# Nielsen PAM ER+ (noscale)
sum(tab_pam_noscale[3:4,1])/sum(tab_pam_noscale)
```
Now we're going to see what happens when we predict Tumor Grade using a built PAM model and a TSP model. We want to
determine the effect of normalization on the predictions, and whether or not the predictions are invariant.

```{r grade, cache=TRUE, fig.width=15, fig.height=12, eval=TRUE, warning=FALSE}
# We're going to work with GSE5460 (hgu133plus2) and ISDB10828 (agilent)
# Let's see what happens when we build models using both PAM and TSP
# on unscaled and scaled (2 ways) data, and predict on unscaled and scaled data
# FOR GRADE

set.seed(8101)
dat <- eset.all$GSE7390
idx_grade <- which(pData(dat)$grade != 2)
mat <- exprs(dat)[,idx_grade] # Just take the 1's and 3's
outcome <- pData(dat)$grade[idx_grade]
genes <- unlist(sapply(PAM50_names, function(x){rownames(fData(dat))[which(fData(dat)$SYMBOL == x)]}))
mat <- mat[genes,]
mat_norm_q <- normalize.quantiles(mat)
mat_norm_r <- t(apply(mat, 1, function(x){(rescale(x, q=0.05) - 0.5) * 2}))

idx <- sample(1:ncol(mat),round(ncol(mat)/3))
train <- mat[,-idx]
test <- mat[,idx]
train_norm_q <- mat_norm_q[,-idx]
test_norm_q <- mat_norm_q[,idx]
train_norm_r <- mat_norm_r[,-idx]
test_norm_r <- mat_norm_r[,idx]

dimnames(train_norm_q) <- dimnames(train_norm_r) <- list(rownames(train), colnames(train))
dimnames(test_norm_q) <- dimnames(test_norm_r) <- list(rownames(test), colnames(test))

train_outcome <- outcome[-idx]
test_outcome <- outcome[idx]

# First we train the PAM classifier
pam_dat <- list(x=train, y=train_outcome, geneids=rownames(train))
pam_dat_q <- list(x=train_norm_q, y=train_outcome, geneids=rownames(train_norm_q))
pam_dat_r <- list(x=train_norm_r, y=train_outcome, geneids=rownames(train_norm_r))
pam_er <- pamr.train(pam_dat)
pam_er_q <- pamr.train(pam_dat_q)
pam_er_r <- pamr.train(pam_dat_r)
pam_er_cv <- pamr.cv(pam_er, pam_dat)
pam_er_cv_q <- pamr.cv(pam_er_q, pam_dat_q)
pam_er_cv_r <- pamr.cv(pam_er_r, pam_dat_r)

# 14, 15, 15
thresh_er <- 1.5
thresh_er_q <- 1.2
thresh_er_r <- 1.55

# Create sbt models for scaled and unscaled so that we can do predictions using intrinsic.cluster.predict

final_genes <- pamr.listgenes(pam_er, pam_dat, thresh_er)[,"id"]

pam_er_sbt_scaled <- pam50.robust
cent <- pam_er$centroids[final_genes,]
cent_map <- fData(dat)[rownames(cent),]
cent_map <- data.frame("probe"=cent_map$SYMBOL, "probe.centroids"=cent_map$SYMBOL, "EntrezGene.ID"=cent_map$ENTREZID)
rownames(cent_map) <- cent_map$probe
rownames(cent) <- fData(dat)[rownames(cent), "SYMBOL"]
pam_er_sbt_scaled$centroids <- cent
pam_er_sbt_scaled$centroids.map <- cent_map

rownames(test) <- fData(dat)[rownames(test),"SYMBOL"]
preds_pam_scaled <- intrinsic.cluster.predict(pam_er_sbt_scaled, t(test), pam_er_sbt_scaled$centroids.map)$subtype

pam_er_sbt_unscaled <- pam_er_sbt_scaled
pam_er_sbt_unscaled$std <- "none"
preds_pam_unscaled <- intrinsic.cluster.predict(pam_er_sbt_unscaled, t(test), pam_er_sbt_scaled$centroids.map)$subtype

# Now we build the TSP model
tsp_er <- rpart_cond(train, train_outcome, 5)
pairmat_er <- calculateTspairs(train, tsp_er)
tree_er <- create_model_tree(pairmat_er$pairMat, train_outcome, tsp_er)

tsp_er_q <- rpart_cond(train_norm_q, as.factor(train_outcome), 5)
pairmat_er_q <- calculateTspairs(train_norm_q, tsp_er_q)
tree_er_q <- create_model_tree(pairmat_er_q$pairMat, train_outcome, tsp_er_q)

tsp_er_r <- rpart_cond(train_norm_r, as.factor(train_outcome), 5)
pairmat_er_r <- calculateTspairs(train_norm_r, tsp_er_r)
tree_er_r <- create_model_tree(pairmat_er_r$pairMat, train_outcome, tsp_er_r)

test_preds_er <- predict_model_tree(test, genes, tree_er, tsp_er)
test_preds_er_q <- predict_model_tree(test_norm_q, genes, tree_er_q, tsp_er_q)
test_preds_er_r <- predict_model_tree(test_norm_r, genes, tree_er_q, tsp_er_q)

# Now we build a chimera
chim_dat <- build_chimera(eset.all[c(6,13,14,18,23)], "grade", 125) # All affy datasets
chim_grade_idx <- which(chim_dat$outcome != 2)
chim_mat <- chim_dat$data[,chim_grade_idx]
chim_outcome <- chim_dat$outcome[chim_grade_idx]
chim_genes_ids <- rownames(eset.all[[28]])[which(fData(eset.all[[28]])$SYMBOL %in% PAM50_names)]
chim_gene_rows <- which(rownames(chim_mat) %in% chim_genes_ids)
chim_genes <- rownames(chim_mat)[chim_gene_rows]
chim_mat <- chim_mat[chim_gene_rows,]
chim_idx <- sample(1:ncol(chim_mat),round(ncol(chim_mat)/3))

chim_train <- chim_mat[,-chim_idx]
chim_test <- chim_mat[,chim_idx]

chim_train_outcome <- chim_outcome[-chim_idx]
chim_test_outcome <- chim_outcome[chim_idx]

chim_tsp <- rpart_cond(chim_train, chim_train_outcome, 5, c(2,1))
chim_pairmat <- calculateTspairs(chim_train, chim_tsp)
chim_tree <- create_model_tree(chim_pairmat$pairMat, chim_train_outcome, chim_tsp)

chim_test_preds <- predict_model_tree(chim_test, chim_genes, chim_tree, chim_tsp)

# Let's see how all models do on an external test set of a completely different platform
# We will test on Illumina and Agilent datasets

# ILLUMINA
pred_set <- eset.all$ISDB10278
pred_mat <- make_mat(exprs(pred_set), genes)
rownames(pred_mat) <- fData(pred_set)[rownames(pred_mat), "SYMBOL"]

preds_pam2_scaled <- intrinsic.cluster.predict(pam_er_sbt_scaled, t(pred_mat), pam_er_sbt_scaled$centroids.map)$subtype
preds_pam2_unscaled <- intrinsic.cluster.predict(pam_er_sbt_unscaled, t(pred_mat), pam_er_sbt_scaled$centroids.map)$subtype

#preds_pam2 <- pamr.predict(pam_er, make_mat(exprs(pred_set), genes), threshold=thresh_er)
preds_pam2_q <- pamr.predict(pam_er_q, normalize.quantiles(make_mat(exprs(pred_set), genes)), threshold=thresh_er_q)
val_preds_er <- predict_model_tree(exprs(pred_set), genes, tree_er, tsp_er)
val_preds_chim <- predict_model_tree(exprs(pred_set), chim_genes, chim_tree, chim_tsp)
table(preds_pam2_scaled, pData(pred_set)$grade)
table(preds_pam2_unscaled, pData(pred_set)$grade)
table(preds_pam2_q, pData(pred_set)$grade)
table(val_preds_er$pred, pData(pred_set)$grade)
table(val_preds_chim$pred, pData(pred_set)$grade)

# AGILENT
pred_set <- eset.all$ISDB10845
pred_mat <- make_mat(exprs(pred_set), genes)
rownames(pred_mat) <- fData(pred_set)[rownames(pred_mat), "SYMBOL"]

preds_pam2_scaled <- intrinsic.cluster.predict(pam_er_sbt_scaled, t(pred_mat), pam_er_sbt_scaled$centroids.map)$subtype
preds_pam2_unscaled <- intrinsic.cluster.predict(pam_er_sbt_unscaled, t(pred_mat), pam_er_sbt_scaled$centroids.map)$subtype

#preds_pam2 <- pamr.predict(pam_er, make_mat(exprs(pred_set), genes), threshold=thresh_er)
preds_pam2_q <- pamr.predict(pam_er_q, normalize.quantiles(make_mat(exprs(pred_set), genes)), threshold=thresh_er_q)
val_preds_er <- predict_model_tree(exprs(pred_set), genes, tree_er, tsp_er)
val_preds_chim <- predict_model_tree(exprs(pred_set), chim_genes, chim_tree, chim_tsp)
table(preds_pam2_scaled, pData(pred_set)$grade)
table(preds_pam2_unscaled, pData(pred_set)$grade)
table(preds_pam2_q, pData(pred_set)$grade)
table(val_preds_er$pred, pData(pred_set)$grade)
table(val_preds_chim$pred, pData(pred_set)$grade)

# Summarize the above tables into a boxplot

acc <- c(162/(162+8), 167/(167+3), 136/(136+34), 454/(454+503), 807/(807+150), 754/(754+203),
         16/(16+9), 20/(20+5), 17/(17+8), 101/(101+46), 86/(86+61), 85/(85+62))
names <- rep(c("Illumina Grade 1", "Illumina Grade 3", "Agilent Grade 1", "Agilent Grade 3"), each=3)
mod <- rep(c("PAM Scaled", "PAM Unscaled", "TSP"), 4)

dat <- data.frame("acc"=acc, "names"=names, "mod"=mod)

ggplot(dat, aes(names, acc, fill = mod)) +  geom_bar(stat="identity", position = "dodge") + scale_fill_brewer(name="Prediction Method", palette = "Set1") + xlab("Platform/Grade") + ylab("Accuracy")

# Example PAM classification

sample <- mat[,100]
sample_ranks <- rank(sample)

ctr <- pam50$centroids[names(genes),]
ctr_ranks <- apply(ctr, 2, rank)

par(mfrow=c(2,3))

for(i in 1:5){ 
plot(sample_ranks, ctr_ranks[,i], main=colnames(ctr_ranks)[i], xlab="Sample Ranks", ylab=paste(colnames(ctr_ranks)[i], "Ranks"), 
sub=paste("Spearman Correlation=",round(cor(sample, ctr[,i], method="spearman"), 3)), cex=3, 
pch=20, cex.axis=1.3, cex.sub=1.1, cex.lab=1.1, col=colors[i])
}

```


